import sampleImage1 from "../../../assets/blog/blogImage.webp";
import sampleImage2 from "../../../assets/blog/blog-2.webp";
import sampleImage3 from "../../../assets/blog/blog-3.webp";

export const blogData = [
  {
    id: 1,
    subheading: ["Webinar"],
    tags: ["AI", "Security", "Gaps"],
    title: "Deep Dive on Unmasking Security Gaps",
    author: "Anton Frank",
    date: "20 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage1,
  },
  {
    id: 2,
    subheading: ["Analyst Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Radicati Group Secure Email Market Quadrant, 2025",
    author: "Anton Frank",
    date: "20 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage2,
  },
  {
    id: 3,
    subheading: ["Research Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "A Deep Dive into the Leaked Black Basta Chat Logs",
    author: "Anton Frank",
    date: "20 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage3,
  },
  {
    id: 4,
    subheading: ["Webinar"],
    tags: ["AI", "Security", "Gaps"],
    title: "The Future of AI-Driven Security",
    author: "John Doe",
    date: "21 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage1,
  },
  {
    id: 5,
    subheading: ["Analyst Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Cloud Security Trends 2025",
    author: "John Doe",
    date: "22 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage2,
  },
  {
    id: 6,
    subheading: ["Research Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Insider Threat Detection in Hybrid Work Environments",
    author: "John Doe",
    date: "23 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage3,
  },
  {
    id: 7,
    subheading: ["Webinar"],
    tags: ["AI", "Security", "Gaps"],
    title: "Next-Gen Endpoint Protection",
    author: "Anton Frank",
    date: "24 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage1,
  },
  {
    id: 8,
    subheading: ["Analyst Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Cybersecurity for Healthcare 2025",
    author: "John Doe",
    date: "25 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage2,
  },
  {
    id: 9,
    subheading: ["Research Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Threat Intelligence Integration Best Practices",
    author: "Anton Frank",
    date: "26 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage3,
  },
  {
    id: 10,
    subheading: ["Webinar"],
    tags: ["AI", "Security", "Gaps"],
    tags: ["AI", "Security", "Gaps"],
    title: "Building Resilience in Cyber Infrastructure",
    author: "Anton Frank",
    date: "27 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage1,
  },
  {
    id: 11,
    subheading: ["Analyst Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "State of Email Security: Market Insights",
    author: "John Doe",
    date: "28 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage2,
  },
  {
    id: 12,
    subheading: ["Research Report"],
    tags: ["AI", "Security", "Gaps"],
    title: "Advanced Malware Campaigns in 2025",
    author: "Anton Frank",
    date: "29 APR 2025",
    content: [
      "It was a cold and wet Thursday morning, sometime in early 2006. There I was sitting at the very top back row of an awe-inspiring lecture theatre inside Royal Holloway's Founder’s Building while studying for my MSc in Information Security. Back then, the lecture in progress was from the software security module.",
      "The first rule of software security back then was never to trust user inputs. In software, there are sources — where we take the data from (usually the user), and there are sinks — where that data ends up, with “stuff” going on in between that data. Now, at that time, things were a little simpler, I say with my slippers on, pitched back in my rocking armchair by the fire.",
      "We didn't have the complexities we have today in modern software. We still had one or more multiple sources of data coming in typically from a user, or perhaps another system, for which we had to deal with from a security perspective. Namely input validation and then output encoding. Making sure any payloads (or special characters) that could impact the middle “stuff” (and, subsequently, the output) were filtered out. I said simpler, but not easier. It still took many years to deal with buffer overflows, which exploit input validation to get data to be placed into memory to then be treated as instructions instead, to ultimately change the flow of execution. SQL injection is another case of untrusted user input. While it has improved over the years, it isn't going away anytime soon and is a similar injection — an attacker gets to break out of the data context and modify the database query (the command) to do things that were never intended.",
      "An SSRF vulnerability is when software (an application or an API of some sort) takes malicious user input and utilizes it as a value in a server-side function call to actively do something. Because the function directly uses a user-defined input value to do server-side things, you can see where this could go wrong. Typically, input validation is forgotten about here because the danger is not always noticed, or if input validation is remembered, it is placed in the form of a regular expression, which in my experience, can be bypassed nine times out of 10. We can then get this function call to do something the application didn't intend to do.",
    ],
    img: sampleImage3,
  },
];
